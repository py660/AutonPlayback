{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_drive_smart = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nright_drive_smart = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)\ncontroller_1 = Controller(PRIMARY)\nConveyer = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)\nIntake = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nPneumaticClaw = DigitalOut(brain.three_wire_port.a)\nDavidWhacker = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False)\nFlash = DigitalOut(brain.three_wire_port.c)\n\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\ncontroller = controller_1\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\ndef bprint(*args, **kwargs):\n    brain.screen.print(*args, **kwargs)\n    brain.screen.next_row()\n\ndef clearscreen():\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.set_font(FontType.MONO20)\n    brain.screen.set_fill_color(Color.RED)\n    brain.screen.set_pen_color(Color.RED)\n    brain.screen.draw_rectangle(0, 0, 480, 36)\n    brain.screen.set_pen_color(Color.WHITE)\n    bprint(\" \"*15 + \"AutonWriter v1.0.0\")\n    brain.screen.set_font(FontType.MONO12)\n    brain.screen.set_cursor(3,1)\n    bprint(\" \"*18 + \"WRITE MODE ACTIVATED\")\n\nbprint(\"Awaiting controller input...\")\nbrain.screen.set_font(FontType.MONO60)\n\"\"\"SAVE_SLOT_TEMP = -1\n\ncontroller.screen.clear_screen()\ncontroller.screen.print(\"Select a save slot (X=0,Y=1,A=2,B=3)\")\n\ndef setsave(i):\n    SAVE_SLOT_TEMP = i\n\ncontroller.buttonX.pressed(setsave(0))\ncontroller.buttonY.pressed(setsave(1))\ncontroller.buttonA.pressed(setsave(2))\ncontroller.buttonB.pressed(setsave(3))\n\nwhile SAVE_SLOT_TEMP == -1:\n    wait(500, MSEC)\n\nSAVE_SLOT = SAVE_SLOT_TEMP\nclearscreen()\n\"\"\"\nSAVE_SLOT = 0\n\n# CoOoOoOoOol credits, remove in prod\nbrain.screen.set_font(FontType.MONO12)\nbprint(\"-----------------------------------------------\")\nbprint(\"| Submit a PR: github.com/py660/AutonPlayback |\")\nbprint(\"-----------------------------------------------\")\n\nbprint(\"You are saving to save slot #\" + str(SAVE_SLOT))\ncontroller.rumble(\"..\")\n\ntry:\n    bprint(\"Opening drive sequence file for writing...\")\n    fseq = open(\"sequence\" + str(SAVE_SLOT) + \".txt\", \"w+\")\nexcept OSError as e:\n    bprint(\"File IO operation exited with\", e)\n    bprint(\"Did you insert an SD card with an appropriate FS (e.g. FAT32)?\")\n\nbrain.timer.clear()\nbprint(\"File successfully opened. Awaiting inputs...\")\nbprint(\"Tap screen to stop recording.\")\n\ncontroller_1.buttonDown.pressed(lambda: btnupdate(\"Down\", True))\ncontroller_1.buttonDown.released(lambda: btnupdate(\"Down\", False))\ncontroller_1.buttonUp.pressed(lambda: btnupdate(\"Up\", True))\ncontroller_1.buttonUp.released(lambda: btnupdate(\"Up\", False))\ncontroller_1.buttonL1.pressed(lambda: btnupdate(\"L1\", True))\ncontroller_1.buttonL1.released(lambda: btnupdate(\"L1\", False))\ncontroller_1.buttonL2.pressed(lambda: btnupdate(\"L2\", True))\ncontroller_1.buttonL2.released(lambda: btnupdate(\"L2\", False))\ncontroller_1.buttonR1.pressed(lambda: btnupdate(\"R1\", True))\ncontroller_1.buttonR1.released(lambda: btnupdate(\"R1\", False))\ncontroller_1.buttonR2.pressed(lambda: btnupdate(\"R2\", True))\ncontroller_1.buttonR2.released(lambda: btnupdate(\"R2\", False))\ncontroller_1.buttonB.pressed(lambda: btnupdate(\"B\", True))\ncontroller_1.buttonB.released(lambda: btnupdate(\"B\", False))\ncontroller_1.buttonX.pressed(lambda: btnupdate(\"X\", True))\ncontroller_1.buttonX.released(lambda: btnupdate(\"X\", False))\ncontroller_1.axis2.changed(lambda: axisupdate(\"Left\", controller.axis2))\ncontroller_1.axis3.changed(lambda: axisupdate(\"Right\", controller.axis3))\n\nlog = []\n\ndef save():\n    for line in log:\n        fseq.write(\"\\t\".join(map(str, line)) + \"\\n\")\n    fseq.close()\n    clearscreen()\n    bprint(\"Done writing!\")\n    while True:\n        wait(100, SECONDS)\n\nbrain.screen.pressed(save)\n\n# 17 rows avail.\n# 480 x 240\n\ndef brainupdate():\n    for line in log[-10:]:\n        clearscreen()\n        bprint(\"\\t\".join(line))\n\nbrainupdate_thread = Thread(brainupdate)\n\ndef btnupdate(key, pressed):\n    log.append((brain.timer.time(MSEC)/1000, key, pressed))\n\ndef axisupdate(side, ctrlaxis):\n    log.append((brain.timer.time(MSEC)/1000, side, ctrlaxis.position()))\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_left_shoulder_control_motors_stopped = True\ncontroller_1_right_shoulder_control_motors_stopped = True\ncontroller_1_x_b_buttons_control_motors_stopped = True\ndrivetrain_l_needs_to_be_stopped_controller_1 = False\ndrivetrain_r_needs_to_be_stopped_controller_1 = False\n\n# mainloop\ndef mainloop():\n  global drivetrain_l_needs_to_be_stopped_controller_1, drivetrain_r_needs_to_be_stopped_controller_1, controller_1_left_shoulder_control_motors_stopped, controller_1_right_shoulder_control_motors_stopped, controller_1_x_b_buttons_control_motors_stopped, remote_control_code_enabled\n  # process the controller input every 20 milliseconds\n  # update the motors based on the input values\n  while True:\n      if True:\n        \n          # calculate the drivetrain motor velocities from the controller joystick axies\n          # left = axis3\n          # right = axis2\n          drivetrain_left_side_speed = controller_1.axis3.position()\n          drivetrain_right_side_speed = controller_1.axis2.position()\n        \n          # check if the value is inside of the deadband range\n          if drivetrain_left_side_speed < 5 and drivetrain_left_side_speed > -5:\n              # check if the left motor has already been stopped\n              if drivetrain_l_needs_to_be_stopped_controller_1:\n                  # stop the left drive motor\n                  left_drive_smart.stop()\n                  # tell the code that the left motor has been stopped\n                  drivetrain_l_needs_to_be_stopped_controller_1 = False\n          else:\n              # reset the toggle so that the deadband code knows to stop the left motor next\n              # time the input is in the deadband range\n              drivetrain_l_needs_to_be_stopped_controller_1 = True\n          # check if the value is inside of the deadband range\n          if drivetrain_right_side_speed < 5 and drivetrain_right_side_speed > -5:\n              # check if the right motor has already been stopped\n              if drivetrain_r_needs_to_be_stopped_controller_1:\n                  # stop the right drive motor\n                  right_drive_smart.stop()\n                  # tell the code that the right motor has been stopped\n                  drivetrain_r_needs_to_be_stopped_controller_1 = False\n          else:\n              # reset the toggle so that the deadband code knows to stop the right motor next\n              # time the input is in the deadband range\n              drivetrain_r_needs_to_be_stopped_controller_1 = True\n        \n          # only tell the left drive motor to spin if the values are not in the deadband range\n          if drivetrain_l_needs_to_be_stopped_controller_1:\n              left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n              left_drive_smart.spin(FORWARD)\n          # only tell the right drive motor to spin if the values are not in the deadband range\n          if drivetrain_r_needs_to_be_stopped_controller_1:\n              right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n              right_drive_smart.spin(FORWARD)\n          # check the buttonL1/buttonL2 status\n          if controller_1.buttonDown.pressing():\n              PneumaticClaw.set(False)\n          elif controller_1.buttonUp.pressing():\n              PneumaticClaw.set(True)\n          # to control Conveyer\n          if controller_1.buttonL1.pressing():\n              Conveyer.set_velocity(2000)\n              Conveyer.spin(FORWARD)\n              controller_1_left_shoulder_control_motors_stopped = False\n          elif controller_1.buttonL2.pressing():\n              Conveyer.set_velocity(200)\n              Conveyer.spin(REVERSE)\n              controller_1_left_shoulder_control_motors_stopped = False\n          elif not controller_1_left_shoulder_control_motors_stopped:\n              Conveyer.stop()\n              # set the toggle so that we don't constantly tell the motor to stop when\n              # the buttons are released\n              controller_1_left_shoulder_control_motors_stopped = True\n          # check the buttonR1/buttonR2 status\n          # to control Intake\n          if controller_1.buttonR1.pressing():\n              Intake.set_velocity(1000)\n              Intake.spin(FORWARD)\n              controller_1_right_shoulder_control_motors_stopped = False\n          elif controller_1.buttonR2.pressing():\n              Intake.set_velocity(1000)\n              Intake.spin(REVERSE)\n              controller_1_right_shoulder_control_motors_stopped = False\n          elif not controller_1_right_shoulder_control_motors_stopped:\n              Intake.stop()\n              # set the toggle so that we don't constantly tell the motor to stop when\n              # the buttons are released\n              controller_1_right_shoulder_control_motors_stopped = True\n          # check the buttonX/buttonB status\n          # to control DavidWhacker\n          if controller_1.buttonB.pressing():\n              DavidWhacker.set_velocity(500)\n              DavidWhacker.spin(FORWARD)\n              controller_1_x_b_buttons_control_motors_stopped = False\n          elif controller_1.buttonX.pressing():\n              DavidWhacker.set_velocity(500)\n              DavidWhacker.spin(REVERSE)\n              controller_1_x_b_buttons_control_motors_stopped = False\n          elif not controller_1_x_b_buttons_control_motors_stopped:\n              DavidWhacker.stop()\n              # set the toggle so that we don't constantly tell the motor to stop when\n              # the buttons are released\n              controller_1_x_b_buttons_control_motors_stopped = True\n      # wait before repeating the process\n      wait(20, MSEC)\n\n\nmainloop_thread = Thread(mainloop)","textLanguage":"python","robotConfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22}],"slot":6,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.5","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}